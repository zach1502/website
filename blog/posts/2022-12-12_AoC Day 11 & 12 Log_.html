<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Zachary Chan | Blog</title>
        <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EJ4J9G467E"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-EJ4J9G467E');
        </script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="A resume site that builds itself in front of you">
        <meta name="keywords" content="resume, co-op, build, site, zach, blog, self">
        <meta name="author" content="Zachary Chan">
        <link rel="icon" type="image/x-icon" href="../../icon.ico">
        <link rel="stylesheet" href="../assets/style.css">
    </head>

    <body>
        <!-- top bit -->
        <div>
            <nav>
                <a href="../index.html" id="main"> Main Page</a>
                <a href="../main_blog.html"> Blog</a>
                <a href="./resume.docx" download> Download My Resume</a>
                <a href="https://github.com/zach1502/website"> Source Code</a>
                <a href="https://github.com/zach1502/"> GitHub</a>
            </nav>
        </div>

        <!-- main content -->
        <!-- centered -->
        <div class="main-content">
            <h1> 
                Monkeys and Paths | AoC Day 11 & 12
            </h1>
            <hr>
            <span>Posted on December 13th, 2022</span>
            <hr>
            <p>
                The difficulty is starting to ramp up. I'm feeling it testing my capabilities now.
            </p>
            <p>
                Day 11's part 1 was about a bunch of monkeys, each holding a bunch of items and you have a certain worry level for each item.
                The challenge was to figure out how much "Monkey Business" there is at round 20 by multiplying the highest and 2nd highest number of items each monkey inspected. 
                This task can be quite difficult, as it involves keeping track of each monkey's attributes and simulating their actions over multiple rounds.
            </p>
            <p>
                The input file contains a list of monkeys, each with their own attributes.
                Each monkey has several attributes that must be considered in order to accurately simulate their actions. 
                These attributes include starting items, operation, test, and if-true and if-false conditions. 
                The starting items list specifies the worry level for each item the monkey is currently holding, in the order they will be inspected. 
                The operation attribute shows how the worry level changes as the monkey inspects an item. 
                For example, an operation like "new = old * 5" means that the worry level after the monkey inspects the item is five times the worry level before inspection.
            </p>
            <p>
                In order to solve this puzzle, it is necessary to carefully plan out the steps involved in simulating the monkeys' actions over multiple rounds. 
                This can be done by creating a loop that iterates over the number of rounds, with each iteration representing a single round of monkey activity. 
                Within the loop, each monkey's turn can be simulated by iterating over the items they are holding and applying the appropriate operations and tests.
                As the simulation progresses, it is important to keep track of how many items each monkey has inspected. 
                This information can then be used to calculate the level of monkey business at the end of the simulation. 
            </p>
            <p>
                I used a struct to represent each monkey in my solution to the monkey puzzle. 
                The struct contained fields for each of the monkey's attributes, including starting items, operation, test, and if-true and if-false conditions.
                This allowed me to easily access and manipulate the data for each monkey as I simulated their actions over multiple rounds.
            </p>
            <p>
                To start, I created a loop that iterated over the number of rounds specified in the prompt.
                Each iteration of the loop represented a single round of monkey activity. 
                Within the loop, I simulated each monkey's turn by iterating over the items they were holding and applying the appropriate operations and tests. 
                As each monkey inspected an item, I updated their worry level according to the operation specified in their attributes.
            </p>
            <p>
                After each monkey had inspected an item, I applied the if-true and if-false conditions to determine where the item should be thrown next. 
                I added the item to the recipient monkey's list of starting items, and then repeated the process until all of the monkeys had taken their turn.
            </p>
            <p>
                At the end of the simulation, I calculated the level of monkey business by sorting the total number of items each monkey had inspected in descending order.
                I then multiplied the highest and 2nd highest numbers of items inspected to get the level of monkey business.
            </p>

            <p>
                Part 2's twist was that now, we have to simulate <strong>10000</strong> rounds instead of 20.
                The numbers here get really big. I had to use some modular arithmetic tricks to get the right answer.
            </p>
            <p>
                I took advantage of the fact that any multiple of x is congruent to y mod x.
                I multipled the moduluses of each monkey together and used that to mod the item at every single step.
                This allowed me to get the right answer without the integers overflowing. 
                I'm really glad I have a good memory. I had to study the foundations of number theory in my discrete math class about 6 months ago.
            </p>
            <p>
                Other than this, part 2 was trivial.
                I changed the number of loops to 10000 and then apply the super cool modular arithmetic trick.
            </p>
            <p>
                Part 1 took a recorded time of 32:56 (Rank 2159) and part 2 took 33:12 (Rank 766).
            </p>

            <p>
                Day 12's part 1 was about finding the path on a mountain.
                The puzzle involves navigating a grid of squares, each with a unique elevation represented by a lowercase letter. 
                The goal is to move from your current position (S) to the location that should get the best signal (E) in as few steps as possible.
            </p>
            <p>
                I recognized two challenges here. 
                One of the biggest challenges in solving this puzzle is understanding the rules for moving from one square to another. 
                In order to avoid needing to use climbing gear, the elevation of the destination square can be at most one higher than the elevation of your current square. 
                This means that you can move to a lower square, but not to a higher one. 
                This adds an extra layer of complexity to the puzzle, as you must carefully plan your route to avoid getting stuck at a higher elevation.
            </p>
            <p>
                Another challenge in solving this puzzle is finding the optimal path from your current position to the destination. 
                The grid is full of paths you can't take and there may be multiple paths to the destination. 
                It is up to you to carefully analyze the grid and choose the path that will take the fewest steps. 
                This requires careful observation and strategic thinking, as well as the ability to adapt to changing conditions on the grid.
            </p>

            <p>
                For the first time this AoC season, I used python instead of C++ for this puzzle.
                The reason being is that I had a library specifically for graphs that I could use that will completely avoid almost all of the challenges.
                Another reason was that I wanted this to be over with so I could watch the Mogul Chess Boxing Championship with my friends.
            </p>

            <p>
                I have to say, I really appreciate the development community behind python and how easy and abstracted everything is!
                I used the networkx library to create a graph of the grid.
                The networkx library in Python is a powerful tool for working with graphs and networks.
                It allows users to easily create, manipulate, and analyze complex network data.
            </p>

            <p>
                The first step in solving this puzzle was to find the starting position (S) and the destination (E).
                They are hiding somewhere in the grid so I had to pick it out first. I used a simple for loop to iterate over the grid and find them.
            </p>

            <p>
                I then used the networkx library and created a directed graph of the grid.
                I then iterated across each char in the grid and checked the possible nodes that could be created.
                if it is inside the graph, I then checked if the elevation of the current node is not more than 1 higher to the elevation of the next node.
                If both conditions are met, I then added an edge from the current node to the next node. I did this for all 4 cardinal directions.
            </p>

            <p>
                I then found the shortest path using the networkx library.
                A simple call to the shortest_path_length function gave me the answer.
            </p>

            <p>
                Part 2 for this question was also trivial. Instead of starting from S, I had to start from any of the lowest elevation nodes, a.
                I just had to iterate over all the nodes and find the shortest path from the shortest path of each a to E.
            </p>
            <p>
                Coincidentally it was 1 lower than my part 1 answer. With that day 2 was done in a breeze. 
            </p>

            <p>
                Part 1 took a time of 17:36 (Rank 774) and part 2 took 18:08 (Rank 552).
                The best result so far!
            </p>
            <p>
                I have jumped to 7th on the Computer Science Student Society (CSSS) leaderboard!
                There is still 106 people in leaderboard.
            </p>

            <p>
                The last two days have been stellar and I am really happy with my progress.
                So far, from what my stats say, I'm really strong at the second half of the puzzles. 
                Which try to simulate the constant changing of requirements and conditions when programming in the real world.
                I also tried to write more in detail what I'm doing to solve each puzzle.
                At the very end, I will post my code for each puzzle.
            </p>
        </div>

        <!-- bottom bit -->
        <div>
            <footer>
                &copy; 2022 Zachary Chan
            </footer>
        </div>
    </body>
</html>