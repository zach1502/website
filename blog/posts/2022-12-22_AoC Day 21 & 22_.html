<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Zachary Chan | Blog</title>
        <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EJ4J9G467E"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-EJ4J9G467E');
        </script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="A resume site that builds itself in front of you">
        <meta name="keywords" content="resume, co-op, build, site, zach, blog, self">
        <meta name="author" content="Zachary Chan">
        <link rel="icon" type="image/x-icon" href="../../icon.ico">
        <link rel="stylesheet" href="../assets/style.css">
    </head>

    <body>
        <!-- top bit -->
        <div>
            <nav>
                <a href="../index.html" id="main"> Main Page</a>
                <a href="../main_blog.html"> Blog</a>
                <a href="./resume.docx" download> Download My Resume</a>
                <a href="https://github.com/zach1502/website"> Source Code</a>
                <a href="https://github.com/zach1502/"> GitHub</a>
            </nav>
        </div>

        <!-- main content -->
        <!-- centered -->
        <div class="main-content">
            <h1> 
                Monkey Math & A Cube | AoC Day 21 & 22
            </h1>
            <hr>
            <span>Posted on December 22th, 2022</span>
            <hr>
            <p>

            </p>
            <p>
                Day 21 has the monkeys return for another puzzle!
                This time, the monkeys are not stealing our stuff, but instead are giving us a puzzle.

            </p>
            <p>
                Each monkey has a name and has a certain job.
                Some monkeys will yell out a number, others will take the numbers yelled by 2 other monkeys and perform an operation on them.
            </p>
            <p>
                Part 1's goal is to find what number the monkey named "root" will yell.
            </p>
            <p>
                With how the question is set up, I thought recursion would be the best way to solve this. Since essentially we are traversing a tree of numbers or operations.
                I created a struct "shout" that holds the operation and the 2 monkeys that will perform the operation or the number that the monkey will yell.
                I then created an unordered_map to store the monkey's names and their shouts.
            </p>
            <p>
                I looped through the input and created a shout for each monkey. I then stored the shout in the map.
            </p>
            <p>
                I then created a recursive function that takes in the map and the name of the monkey we want to find the number for.
                If the monkey has a number that isn't the default value, return that number.
                Otherwise, get the 2 monkeys' names and call the function on them. Afterwhich, perform the operation on the 2 numbers and return the result.
            </p>
            <p>
                A very simple part 1. Of course, given that monkeys were involved, I had to name my function, "monkeMagick" :D
            </p>
            <p>
                Part 2's twist was that apparently, we misread their instructions! root's operation was actually an == operation and the monkey named "humn" is actually us!
                We now need to think of the right number to shout, so that root's operation will return true.
            </p>
            <p>
                There wasn't actually much to change for part 2. I first adjusted my function so that it took in another parameter, the value of "humn". 
                Then if this number is equal or greater than 0 and the value we wanted to get from is "humn", we returned the value we assigned to humn instead of its original contents.
            </p>
            <p>
                Once that was done, I assumed because we only perform addition, subtraction, multiplication and division, that the value of humn would always increase if we increase humn.
                Then I needed to figure out which side of the tree has humn. This is important since we need to figure out what value is on the other side of the tree. 
                Then we can apply a search on the value of humn. 
                I then used a binary search to find the value of humn that would make root's operation return true.
                And that was it! Problem solved!
            </p>
            <p>
                Part 1 took a time of 30:50 (Rank 2999) and part 2 took 32:26 (Rank 677).
                A pretty clutch part 2!
            </p>
            <p>
                Day 22 was about traversing a map and following the instructions given. If we were to walk into a wall, we do not move and continue with the next instruction.
                If we were to walk off the map, we wrap around to the other side. The challenge that lies here is that the map is in an irregular shape.
            </p>
            <p>
                Part 1's goal is to findout the final location and our orientation after following the instructions.
                We take the row and column of the starting location and, the orientation, and
                multiply the final row by 1000, plus 4 * the final column + the orientation, facing right is 0 and going clockwise is +1.
                That will be our answer.
            </p>
            <p>
                First thing I did was create a map of the orientation corresponding to a direction. I also have the reverse of this map for look ups.
                I also parsed the grid into a 2D vector of characters and I manually extracted the string of instructions.
            </p>
            <p>
                I parsed the instructions into two vectors, one for the number of steps and one for rotations.
                With that done, I looped through each pair of instructions and updated the orientation and location accordingly through a function I wrote.
                I then multiplied the row by 1000 and added 4 * the column and the orientation and that was that.
            </p>
            <p>
                Part 2's twist, I really like.
            </p>
            <p>
                Turns out, we were standing on a cube this entire time! Not some 2D plane.
            </p>
            <p>
                Everything is the same except now we are on a cube so the wrapping rules are different. If we go off the top, we wrap around to the back face of the cube and our orientation changes!
                This was actually a lot more complicated than I thought it would be.
            </p>
            <p>
                I tried to solve it for the general case for a little bit but after realizing I don't have the mathematical knowledge to do so, I decided to just hard code it.
                I cut the cube into 6 faces and depending on which face we are on and which direction we were travelling in. I would give it different warping rules.
                Worked like a charm!
            </p>
            <p>
                Part 1 took a time of 1:25:54 (Rank 2387) and part 2 took 2:00:31 (Rank 576).
            </p>
            <p>
                I am now 5th on the Computer Science Student Society (CSSS) leaderboard. Down from 4th.
                The gap to 4th is 41 points and the gap to 6th is 193 points.
                There are still 109 people in leaderboard.
            </p>
            <p>
                I expect the rankings to change a lot in the next few days as people catch up on the questions they're not doing.
            </p>
        </div>

        <!-- bottom bit -->
        <div>
            <footer>
                &copy; 2022 Zachary Chan
            </footer>
        </div>
    </body>
</html>